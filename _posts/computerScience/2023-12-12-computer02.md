---
title:  "운영체제"
category: computerScience
typora-root-url: ../
toc: true
toc_sticky: true
---

## <br>운영체제(Operating System)

> 일반적으로 커널(kernel)에 여러가지가 추가된 상태를 OS라고 통칭

- 커널(kernel) : 컴퓨터 자원(CPU, Memory, File, Network, IO Devices)을 관리 

- 주요 운영체제: 윈도우, UNIX 계열 OS(Linux), MacOS

### <br>쉘(Shell)

- 사용자가 운영체제 기능과 서비스를 조작할 수 있도록 **인터페이스를 제공**하는 프로그램
- 터미널 환경(CLI)과 GUI 환경으로 분류

### <br>시스템 콜(System Call)

- 운영체제가 운영체제 각 기능을 사용할 수 있도록 시스템 콜이라는 명령 또는 함수를 제공

- 쉘에서 시스템콜을 이용하여 커널에 접근

### <br>API

- Application Programming Interface의 약자로 응용프로그램을 만들기 위한 함수 또는 라이브러리이다.
- API내부에는 필요시 해당 운영체제의 시스템콜을 호출하는 형태로 만들어짐

### <br>사용자 모드와 커널 모드

- 함부로 응용 프로그램이 전체 컴퓨터 시스템을 헤치지 못함
  - 사용자 모드에서 커널 모드로 바로 접근 불가(사용자 모드 > 시스템콜 > 쉘 > 커널 순서로 접근)

<img src="/../images/2023-12-12-computer02/cn.png" alt="cn" style="zoom: 65%;" />

### <br>운영체제 역할

1. 시스템 자원(System Resource) 관리
2. 사용자와 컴퓨터간의 커뮤니케이션 지원
3. 응용 프로그램 제어

## <br>프로세스(Process)

- 실행 중인 프로그램은 프로세스라고 함
  - 프로세스: 메모리에 올려져서 실행중인 프로그램
  - 코드 이미지(바이너리): 실행 파일(Excel.exe)
- 응용 프로그램은 여러 프로세스로 구성 가능
- 스케쥴러: 커널안의 스케쥴러에서 프로세스 실행을 관리

### <br>프로세스 스케쥴링

- 배치처리 시스템: 한번에 등록된 여러 프로그램들을 실행 요청 순서에 따라 순차적으로 실행하는 시스템
  - 단점1: 프로그램의 실행시간을 알 수 없다.
  - 단점2: 동시에 여러 응용 프로그램을 실행시킬 수 없다.

- 시분할 시스템: 다중 사용자 지원을 위해 컴퓨터 **응답 시간을 최소화** 하는 시스템

- 멀티 태스킹: 단일CPU에서 여러 응용 프로그램이 동시에 실행되는 것처럼 보이도록 하는 시스템
- 멀티 프로그래밍: 최대한 CPU를 많이 활용하도록 하는 시스템

### <br>스케쥴링 알고리즘

- FIFO(First In First Out) 스케쥴링
  - 가장 간단한 스케쥴링 알고리즘(배치 처리 시스템)
  - FCFS(First Come First Served) 스케쥴러
  - 자료구조 : Queue
- SJF(Shortest Job First) 스케쥴링
  - 가장 프로세스 시간이 짧은 프로세스부터 먼저 실행을 시키는 알고리즘
  - 자료구조 : Priority Queue, Heap

- 우선순위 기반 스케쥴러
  - 정적 우선순위
    - 프로세스마다 우선순위를 미리 지정
  - 동적 우선순위
    - 스케쥴러가 상황에 따라 우선순위를 동적으로 변경
- 라운드 로빈(Round-Robin) 스케쥴러
  - 프로세스가 일정시간동안 완료 되지 않으면 남은 부분을 큐에 넣는다. 



:sparkles:**가끔 이야기가 나오는 용어 알아두기**

- RTOS(RealTime OS): 응용 프로그램 실시간 성능 보장을 목표로 하는 OS
  - 정확하게 프로그램 시작,완료 시작을 보장
- GPOS(General Purpose OS)
  - 프로세스 실행시간에 민감하지 않고 일반적인 목적으로 사용되는 OS
  - 예시: Windows, Linux 등



:sparkles:**성능을 위해 체크해야하는 포인트**

- IO-bound: IO관련 기능이 주로 사용하는 프로그램
- CPU-bound: CPU/메모리를 주로 사용하는 프로그램

### <br>프로세스 구조

- text(CODE): 코드
- data: 전역 변수/초기화된 데이터
- stack: 임시 데이터(함수 호출,로컬 변수 등)
- heap: 코드에서 동적으로 만들어지는 데이터 또는 객체

<img src="/../images/2023-12-12-computer02/process.jpg" alt="process" style="zoom:80%;" />

 :sparkles:**프로세스와 컴퓨터 구조**

- PC(Program Counter) + SP(Stack Point)
  - PC: 다음 실행할 코드 주소
  - SP: 스택 최상단 주소

<br>:sparkles:**Java Garbage Collection와 프로세스 힙**

- Java Garbage Collection이 필요한 이유
  - 불필요한 객체가 차지하는 힙 공간을 삭제하여 힙 공간 확보가 필요하기 때문
  - 만약 힙 공간이 부족하다면? 객체 생성이 불가능하고 Java와 같은 객체지향 프로그램은 동작하지 않게 됨

### <br>컨텍스트 스위칭(Context Switching)

- CPU에 실행할 프로세스를 교체하는 기술
- 컨텍스트 스위칭 동작
  1. 실행 중지할 프로세스 정보를 해당 프로세스의 PCB에 업데이트해서 메인 메모리에 저장
  2. 다음 실행할 프로세스 정보를 메인 메모리에 있는 PCB정보를 CPU의 레지스터에 넣고 실행

#### <br>PCB(Process Control Block)

- 메모리의 별도 공간에 process 상태값들을 저장

- PCB 저장내용: Process ID, Register(PC,SP 등), 프로세스 상태, 메모리 사이즈 등

### <br>IPC(InterProcess Communication)

- 프로세스 간 통신이 필요한 이유
  - 성능을 높이기 위해 여러 프로세스를 만들어서 동시 실행
  - 프로세스간 상태 확인 및 데이터 송수신 필요하지만 프로세스는 다른 프로세스의 공간에 접근 불가

- IPC는 프로세스간 통신 방법을 제공
  - 대부분 IPC기법은 커널 공간을 활용(Message Queue, Shared Memory, Pipe)

<img src="/../images/2023-12-12-computer02/SharedMemory.png" alt="SharedMemory" style="zoom: 40%;" />



## <br>스레드(Thread)

- **하나의 프로세스에 여러개의 스레드** 생성 가능
- 스레드들은 동시에 실행 가능
- 프로세스 안에 있으므로 프로세스의 데이터를 모두 접근 가능

#### <br>멀티 스레드(Multi Thread)

- 소프트웨어 병행 작업 처리를 위해 사용

### <br>Thread 장점

- 사용자에 대한 응답성 향상
- 자원 공유 효율
  - 프로세스 안에 있으므로 프로세스의 데이터를 모두 접근 가능
  - IPC 기법과 같이 프로세스간 자원 공유를 위해 번거로운 작업이 필요 없음
- 작업이 분리되어 코드가 간결

### <br>Thread 단점

- 스레드 중 한 스레드만 문제가 있어도 전체 프로세스가 영향을 받음
- 스레드를 많이 생성하면 Context Switching이 많이 일어나 성능 저하
- 동기화 이슈로 비정상적으로 동작가능

### <br>동기화(Syncronization) 이슈

- 동기화 : 작업들 사이에 실행시기를 맞추는 것
- 여러 스레드가 동일한 자원(데이터) 접근시 동기화 이슈 발생
  - 동일 자원을 여러 스레드가 동시 수정 시 각 스레드 결과에 영향을 줌

### <br>동기화 이슈 해결 방안

> 임계 자원(Critical Resource): 동시에 읽고 쓰게 되는 데이터
>
> 임계 영역(Critical Section): 임계 자원이 포함된 코드를 가진 영역

- Mutual exclusion(상호 배제)

  - 어느 한 스레드가 공유 변수를 갱신하는 동안 다른 스레드가 동시 접근 할 수 없게 차단
  - Mutex(binary semaphore)
    - 임계 구역에 하나의 스레드만 들어갈 수 있음

  - 세마포어(Semaphore)
    - 임계 구역에 여러 스레드가 들어갈 수 있음
    - Counter를 두어서 동시에 리소스에 접근할 수 있는 허용 가능한 스레드 수 제어



#### <br>교착상태(Deadlock)

- 무한 대기 상태: 두 개 이상의 작업이 서로 상대방의 **작업이 끝나기만을 기다리고 있기 때문에** 다음 단계로 진행하지 못하는 상태

#### 기아상태(Starvation)

- 특정 프로세스의 **우선순위가 낮아서** 원하는 자원을 계속 할당 받지 못하는 상태



## <br>가상 메모리(Virtual Memory System)

> 리눅스의 경우 하나의 프로세스가 4GB, 통상 메모리는 8GB, 16GB?

- 실제 메모리보다 많아 보이게 하는 기술
- 프로세스는 가상 주소를 사용하고 실제 해당 주소에서 데이터를 읽고 쓸때만 물리주소로 변경
  - 가상 주소(Virtual Address): 프로세스가 참고하는 주소
  - 물리 주소(Physical Address): 실제 메모리 주소

- MMU(Memory Management Unit): CPU에서 코드 실행 시 가장 주소 메모리 접근이 필요할 때 해당 주소를 물리 주소값으로 변환해주는 하드웨어 장치

### <br>페이징 시스템(Paging System)

- 크기가 동일한 페이지로 가상 주소 공간과 이에 매칭하는 물리 주소 공간을 관리
- 페이지 번호를 기반으로 가상 주소/물리 주소 매핑 정보를 기록/사용

- 페이지(Page) : 고정된 크기의 block
- 페이지 테이블(Page Table)
  - 물리 주소에 있는 페이지 번호와 해당 페이지의 첫 물리주소 정보를 매핑한 표
  - 가상주소 v = p(페이지번호), d(페이지 처음부터 해당위치까지의 거리)
- 페이징 시스템 동작
  1. 해당 프로세스의 페이지 테이블에 해당 가상주소가 포함된 페이지번호가 있는지 확인
  2. 페이지번호가 있으면 이 페이지가 매핑된 첫 물리주소를 찾음(P')
  3. P' + d 가 실제 물리주소 

### <br>페이징 시스템과 MMU

- CPU는 가상 주소 접근시 MMU하드웨어 장치를 통해 물리 메모리 접근
- 프로세스 생성 시 페이지 테이블 정보 생성
  1. PCB 등에서 해당 페이지 테이블 접근 가능하고 관련 정보는 물리 메모리에 적재
  2. 프로세스 구동시 해당 페이지 테이블 base 주소가 별도 레지스터에 저장(CR3)
  3. CPU가 가상 주소 접근시 MMU가 테이블 base주소를 접근해서 물리 주소를 가져옴

### <br>TLB(Translation Lookaside Buffer)

- 페이지 정보 캐쉬
  1. MMU가 페이지 테이블이 저장되는 메모리를 가리키는 주소를 읽음
  2. 1번에서 찾은 물리주소를 바탕으로 데이터를 찾음
- 위와 같이 2번의 메모리 접근을 하는데 1번의 내용을 TLB에 저장하여 속도를 향상

<img src="/../images/2023-12-12-computer02/mmu1.webp" alt="mmu1" style="zoom:80%;" />



### <br>요구 페이징(Demand Paging)

- 프로세스 모든 데이터를 메모리로 적재하지 않고 실행 중 **필요한 시점에만 메모리로 적재**함

#### <br>페이지 폴트(Page fault)

- 어떤 페이지가 실제 물리 메모리에 없을 때 일어나는 인터럽트
- 운영체제가 page fault가 일어나면 해당 페이지를 물리 메모리에 올림

#### <br>인터럽트

- CPU가 특정 기능을 수행하는 도중에 급하게 다른 일을 처리하고자 할 때 사용할 수 있는 기능

<img src="/../images/2023-12-12-computer02/interrupt.png" alt="interrupt" style="zoom:50%;" />

- 인터럽트는 미리 정의되어 각각 번호와 실행코드를 가리키는 주소가 기록되어있음
- IDT(Interrupt Descriptor Table): 부팅시 운영체제가 정해놓은 인터럽트 정보 저장소

#### <br>스레싱(Thrashing)

- 반복적으로 페이지 폴트가 발생해서 과도하게 페이지 교체 작업이 일어나 실제로는 아무일도 하지 못하는 상황



### 페이지 교체 정책(Page Replacement Policy)

- 운영체제가 특정 페이지를 물리 메모리에 올리려 하는데 다 차있다면?
  1. 기존 페이지 중 하나를 물리 메모리에서 저장매치로 내리고(저장)
  2. 새로운 페이지를 해당 물리 메모리에 올림
- 페이지 교체 알고리즘
  - FIFO(First In First Out): 가장 먼저 들어온 페이지를 교체
  - OPT(Optimal): 앞으로 가장 오랫동안 사용하지 않을 페이지를 교체(구현 불가)
  - LRU(Least Recently Used): 가장 오래 전에 사용된 페이지를 교체
  - LFU(Least Frequently used): 가장 적게 사용된 페이지를 교체
  - NUR(Not Used Recently): LRU와 마찬가지로 최근에 사용하지 않는 페이지부터 교체
    - 각 페이지마다 참조비트(R), 수정비트(M)를 둠(R,M)
    - (0,0), (0,1), (1,0), (1,1) 순으로 교체

## <br>파일 시스템

- 운영체제가 저장매체에 파일을 쓰기 위한 자료구조 또는 알고리즘

- 저장매체에 효율적으로 파일을 저장하는 방법

  > 외부 단편화: 여유 공간이 여러 사이즈로 나뉘는 현상

  1. 가능한 연속적인 공간에 파일을 저장하는 방법
  2. 파일 사이즈 변경 문제로 불연속 공간에 파일 저장 기능 필요
     - 블록 체인: 블록을 링크드 리스트로 연결
       - 끝에 있는 블록을 찾으려면 맨 처음 블록부터 주소를 찾아가야함
     - 인덱스 블록 기법: 각 블록에 대한 위치 정보를 기록해서 한번에 끝 블록을 찾아갈 수 있도록 함

### <br>inode 방식



가상 머신

외부 단편화

